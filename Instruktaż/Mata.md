# 4. **Mata sterująca**

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_0.png>

## **Lista wymaganych materiałów:**

1. **Raspberry Pi Zero W 512MB RAM - WiFi + BT 4.1** - 1 sztuka
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_1.jpg width="30%" height="30%">
</p>

**Przykładowy link do sklepu:**

[https://botland.com.pl/pl/moduly-i-zestawy-raspberry-pi-zero/8330-raspberry-pi-zero-w-512mb-ram-wifi-bt-41.html?search_query=pi+zero&results=191](https://botland.com.pl/pl/moduly-i-zestawy-raspberry-pi-zero/8330-raspberry-pi-zero-w-512mb-ram-wifi-bt-41.html?search_query=pi+zero&results=191) 

[https://botland.com.pl/pl/gniazda-szpilkowe-goldpin/12659-wtyk-goldpin-2x20-prosty-raster-254mm.html](https://botland.com.pl/pl/gniazda-szpilkowe-goldpin/12659-wtyk-goldpin-2x20-prosty-raster-254mm.html) 

2. **Płytka uniwersalna:**
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_2.jpg width="30%" height="30%">
</p>

**Przykładowy link do sklepu:** 

[9cm x 15cm](https://www.gotronik.pl/uniwersalna-plytka-drukowana-pcb-9x15cm-1836-otworow-pol-kontaktowych-p-1273.html)
[2cm x 8cm](https://www.gotronik.pl/uniwersalna-plytka-drukowana-pcb-2x8cm-168-otworow-pol-kontaktowych-p-1268.html)

Wymiary minimalne:  9cm x 15cm

Komentarz: + dodatkowa 2cm x 8cm do budowy płytki zasilającej

3. **Części do płytki drukowanej:**

**Przykładowy link do sklepu:** 

[https://botland.com.pl/pl/laminaty/1054-laminat-fr4-dwustronny-rozmiar-l.html](https://botland.com.pl/pl/laminaty/1054-laminat-fr4-dwustronny-rozmiar-l.html) 

[https://botland.com.pl/pl/laminaty/1943-laminat-dwustronny-150x210mm.html](https://botland.com.pl/pl/laminaty/1943-laminat-dwustronny-150x210mm.html)[ ](https://botland.com.pl/pl/laminaty/1943-laminat-dwustronny-150x210mm.html)

[https://botland.com.pl/pl/wytrawiacze/1057-wytrawiacz-b327-100g-5901764329183.html?search_query=wytrawiacz&results=7](https://botland.com.pl/pl/wytrawiacze/1057-wytrawiacz-b327-100g-5901764329183.html?search_query=wytrawiacz&results=7) 

 

4. **Zasilanie do RPi - L7805CV** - 1 sztuka.
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_3.png width="30%" height="30%">
</p>

**Przykładowy link do sklepu:**

[https://abc-rc.pl/product-pol-6839-Elektronika-Stabilizator-L7805CV-5V-1-5A-obudowa-TO-220.html](https://abc-rc.pl/product-pol-6839-Elektronika-Stabilizator-L7805CV-5V-1-5A-obudowa-TO-220.html)

* Napięcie wyjściowe: 5V
* Maksymalne napięcie wejściowe: 35V
* Prąd wyjściowy: 1,5A
* Liczba pinów: 3
* Obudowa: TO-220
* Nr katalogowy: SNL7805CV

5. **Baterie - Model: "18650"** - 1 sztuka.
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_4.png width="30%" height="30%">
</p>
[https://botland.com.pl/pl/koszyki-na-baterie/5241-koszyk-na-3-baterie-typu-18650.html?search_query=koszyk+18650&results=5](https://botland.com.pl/pl/koszyki-na-baterie/5241-koszyk-na-3-baterie-typu-18650.html?search_query=koszyk+18650&results=5)  

[https://www.gotronik.pl/akumulator-li-ion-18650-ogniwo-litowo-jonowe-3400-mah-panasonic-ncr-18650b-p-6931.html](https://www.gotronik.pl/akumulator-li-ion-18650-ogniwo-litowo-jonowe-3400-mah-panasonic-ncr-18650b-p-6931.html)

(same baterie można dużo taniej znaleźć na Allegro lub OLX)

6. **Wtyk goldpin 2x40 prosty raster 2,54mm** - 1 raster powinien wystarczyć. 
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_5.jpg width="30%" height="30%">
</p>

**Przykładowy link do sklepu:** 

[https://botland.com.pl/pl/gniazda-szpilkowe-goldpin/204-wtyk-goldpin-2x40-prosty-raster-254mm.html?results=76&search_query=goldpin](https://botland.com.pl/pl/gniazda-szpilkowe-goldpin/204-wtyk-goldpin-2x40-prosty-raster-254mm.html?results=76&search_query=goldpin)

7. **Tact Switch 12x12mm z nasadką**- 18 sztuk
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_6.jpg width="30%" height="30%">
</p>

**Przykładowy link do sklepu:**

[https://botland.com.pl/pl/tact-switch/11138-tact-switch-12x12mm-z-nasadka-kwadrat-czarny-5szt.html?search_query=przycisk+tact&results=45](https://botland.com.pl/pl/tact-switch/11138-tact-switch-12x12mm-z-nasadka-kwadrat-czarny-5szt.html?search_query=przycisk+tact&results=45) 

8. **Wyświetlacz OLED niebieski graficzny 1,3'' 128x64px I2C v2** - 1 sztuka.
<p align="center">
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_7.jpg width="30%" height="30%">
</p>

* Napięcie pracy: od 3,3 V do 5,0 V
* Sterownik: SH1106 (dokumentacja)
* Komunikacja: I2C
* Typ wyświetlacza: OLED
* Przekątna: 1,3"
* Rozdzielczość: 128 x 64 px
* Kolor znaków: biały
* Kąt widzenia: powyżej 160 °
* Temperatura pracy: od -20 °C do 70 °C
* Wymiary: 35 x 33 mm

**Przykładowy link do sklepu:**

[https://botland.com.pl/pl/wyswietlacze-oled/8246-wyswietlacz-oled-niebieski-graficzny-13-128x64px-i2c-v2-niebieskie-znaki.html](https://botland.com.pl/pl/wyswietlacze-oled/8246-wyswietlacz-oled-niebieski-graficzny-13-128x64px-i2c-v2-niebieskie-znaki.html)

## **Budowa maty**

Na wstępie chciałbym zaznaczyć, że uniwersalne płytki PCB dają nam ogromną swobodę w tym jak nasz efekt końcowy będzie się prezentować. 

Przed rozpoczęciem budowy "maty" najlepiej zapoznać się z schematem i wstępnie zaplanować sobie rozkład połączeń na uniwersalnej płytce. Porządek to podstawa, ponieważ później pozwoli nam to na łatwe modyfikacje i naprawy ewentualnych błędów.

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_8.png width="50%" height="50%">

Pierwszym krokiem będzie rozkład przycisków S1 - S16. 

Z racji tego, że wybrana płytka jest dosyć dużych rozmiarów, bo ma aż 9cm na 15cm, to możemy pozwolić sobie na spore odstępy między przyciskami tak jak na poniższym zdjęciu (oczywiście każdy może mieć większe bądź mniejsze odstępy, to już według osobistych preferencji):

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_9.png>

Następnie możemy dodać kolejne dwa przyciski (S17 i S18), które będą przyciskami funkcyjnymi: 

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_10.png>

Teraz gdy już mamy zaplanowane rozłożenie przycisków możemy przejść do przypomnienia sobie schematu samej klawiatury jak i samego przycisku co ułatwi nam lutowanie. 

- Klawiatura:

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_11.png>

- Przycisk: 

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_12.png>

Podstawową rzeczą jaką powinniśmy zauważyć patrząc na schemat przycisku jest fakt, że nóżki 3 i 4 oraz 1 i 2 są ze sobą połączone, więc wciśnięcie przycisku powoduje zamknięcie obwodu między parami nóżek 1,2 i 3,4. Jest to o tyle istotny fakt, że podczas lutowania możemy zaoszczędzić bardzo dużo miejsca jak i czasu poświęconego na pracę. Przejdźmy zatem do lutowania: 

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_13.png width="70%" height="70%">

Na zdjęciu powyżej widzimy pierwszą zlutowaną kolumnę. Oczywiście można było zrobić to inaczej, ale tak jak wspominałem, na płytkach uniwersalnych mamy pełną dowolność.

Poniżej zdjęcia będą przedstawiać postęp w lutowaniu kolumn i wierszy między przyciskami. 

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_14.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_15.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_16.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_17.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_18.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_19.png>

Następnie aby sprawdzić czy wszystko zostało podłączone tak jak należy oraz udało nam się uniknąć "zimnych lutów" możemy na szybko podłączyć klawiaturę do np. Arduino i sprawdzić czy działa poprawnie: 

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_20.png>
(Na czerwono są zaznaczone miejsca w których zostały przylutowane kable od kolumn, a nie ma ich na zdjęciu)

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_21.png>
Powyżej widać klawiaturę podpiętą do Arduino, 

a poniżej widać program oraz wynik na konsoli po naciśnięciu klawiszy. 

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_22.png>

(Kod do Arduino zostanie udostępniony na GitHubie jako plik [test_klawiatury_4x4](https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Kod%20-%20mata/test_klawiatury_4x4.ino))

Po poprawnych wynikach otrzymanych w teście możemy przejść do dodania pinów do klawiatury aby później można było ją podłączyć do RPi Zero. 
(Nie zastosowałem tutaj kabli przylutowanych na stałe, ponieważ nie miałem odpowiednich pod ręką, a kabelki ze skrętki nie były odpowiednie, ponieważ szybko się łamały i były zbyt sztywne)

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_23.png>

Powyżej można zauważyć 4 dodatkowe piny obok przycisków funkcyjnych, ponieważ w międzyczasie został przylutowany ekran OLED co będzie widoczne na następnym zdjęciu: 
<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_24.png>

Po skończonej klawiaturze możemy przejść do zasilania jakiego użyjemy dla naszego Raspberry Pi Zero. 

Ważne jest to aby pamiętać o podstawowych parametrach jakie trzeba zapewnić RPi aby działało stabilnie. Po pierwsze najważniejsze jest napięcie, jeśli chcemy zasilić RPi poprzez złącze microUSB to musimy zapewnić następujące wartości: 

* Napięcie [V]:  4.75 - 5.25
* Natężenie [mA]: min. 500

Jest również możliwość zasilania RPi poprzez GPIO, ale jest to dosyć ryzykowny zabieg. 

Do wykonania prostego zasilacza będziemy potrzebowali: 

* L7805CV
* Koszyk na baterie 3x 18650
* kawałek płytki uniwersalnej
* trochę kabla 
* przełącznik 
* kondensator (ja wybrałem 10v 470uF)
* oraz opcjonalnie można użyć złącz ARK

Na wstępie mały obrazek z wyjściami dla L7805CV aby wszystko poprawnie podłączyć: 

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_25.png>

Następnie schemat całego zasilacza:

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_26.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_27.png>

I końcowy wygląd: 

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_28.png>

Kolejna część praktycznie skończona, więc możemy przejść do kolejnych testów z udziałem Raspberry Pi Zero i naszego zasilacza. 
Na wstępie dodam jeszcze, żeby połączyć zasilacz z Raspberry użyłem starej końcówki microUSB z ładowarki która miała jedynie 2 żyły (czerwoną i czarną) przez co łatwiej było podłączyć ją pod zasilacz. 

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_29.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_30.png>

Na powyższych zdjęciach widzimy pakiet 3 baterii 18650, dwa multimetry z czego jeden mierzy natężenie między zasilaczem a Raspberry (w stanie spoczynku przy uruchomionym systemie Raspbiana oraz podłączonym ekranie poprzez HDMI pobór wynosił około 290-340mA.)

Drugi multimetr (czarny) pokazuje napięcie na wyjściu zasilacza, które u mnie wynosiło 5,04 - 5,05V nawet przy większym obciążeniu RPi. Pakiet baterii na wyjściu miał napięcie w przedziale 12 - 12,10V. 

### **Obudowa maty**

Teraz możemy zostawić elektronikę na boku i przejść do budowy. 

Ja użyłem do tego plexy, ale równie dobrze możemy stworzyć obudowę z drewna lub zaprojektować i wydrukować w drukarce 3D. 

Wymiary obudowy prezentowanej na zdjęciach mają: 

* Wysokość: 70mm 
* Szerokość: 100mm
* Długość: 160mm

Oczywiście szerokość i długość można dopasować idealnie do płytki uniwersalnej i zastosować szerokość 90mm i długość 150mm. 

Zdjęć z samego wycinania nie będzie lecz przedstawię swoje osobiste doświadczenia jakie uzyskałem podczas tego procesu. 

Wskazówki: 

* Do budowy obudowy dobrze jest wykorzystać plexi o grubości 2mm, ponieważ w łatwy sposób możemy ciąć ją nożem do tapet. Po 3-4 mocniejszych nacięciach i mocniejszym nagięciu plexi powinna przełamać się. 
* Dobrze jest też nakleić sobie taśmę papierową i na niej narysować linię gdzie będziemy cięli, ponieważ plastik jest dosyć ślizgi i możemy zrobić sobie krzywdę. 
* Możemy również ciąć wzdłuż kątownika lub innej prostej rzeczy aby nóż nie uciekał na boki. tak aby nie było większych nierówności. 
* Po cięciu brzegi plexi dobrze jest wyrównać papierem ściernym. Ja użyłem 120 i 60
* Ostatnią wskazówką jest to aby nie ciąć plexi wyrzynarką, przynajmniej mi się to nie udało, ponieważ brzeszczot podczas cięcia uzyskuje wysoką temperaturę i topi plexi.

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_31.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_32.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_33.png>

Do połączenia wszystkich elementów użyłem kleju na gorąco, jest on w zupełności wystarczający do tego stopnia, że jak ktoś się pomyli to praktycznie nie da się po ostygnięciu usunąć go w całości z plexi. 

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_34.png>

Ostatnim krokiem jest połączenie wszystkich elementów razem za pomocą kabli z końcówkami żeńska-żeńska i zamknięcie całości w obudowie. Z racji tego, że moja obudowa była większa od płytki PCB, to musiałem po bokach dodać dodatkowe wsporniki aby przyczepić płytkę do obudowy. 
Efekt końcowy po podłączeniu całości i zamontowaniu przełącznika w płytce PCB. 

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_35.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_36.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_37.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_38.png>

<img src=https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Instrukta%C5%BC/Zdj%C4%99ciaMata/image_39.png>

## **Kod do maty**

Tak jak w przypadku robota, pełny kod znajdziesz w linku poniżej, a jeżeli interesujesz się sposobem działania kodu, poniżej znajdziesz opis.

[Kod do maty](https://github.com/domiipl/Projekt-Inz-Pliki/blob/master/Kod%20-%20mata/Mata.js)

### **Instalacja kodu**

Sama instalacja kodu na Raspberry jest dość prosta. Najpierw klonujemy repozytorium
```
git clone https://github.com/domiipl/Projekt-Inz-Pliki
```
Następnie przechodzimy do folderu "Projekt-Inz-Pliki" a później do folderu “Kod - mata” komendami
```
cd Projekt-Inz-Pliki
cd Kod\ -\ mata/
```
i wpisujemy 
```
sudo npm install
```
Czekamy aż zainstalują się biblioteki i wpisujemy kolejną komendę
```
sudo node Mata.js
```
Po zakończonej instalacji kodu, robimy z naszej maliny serwis używając do tego pliku "nodeserver.service". Będąc dalej w folderze “Kod - mata” używamy komendy,
```
systemctl enable nodeserver.service
```
która zezwala na włączenie serwisu, następnie komenda uruchamiająca malinę jako serwis
```
systemctl start nodeserver.service
```
Na koniec możemy jeszcze sprawdzić czy wszystko działa komendą
```
systemctl status nodeserver.service
```
**Opis kodu**

Standardowo, musimy zacząć od dołączenia odpowiednich bibliotek oraz sterowników. Będą nam potrzebne biblioteki odpowiedzialne za komunikację sieciową, komunikację z pinami malinki oraz sterownik do ekranu oled.
```
var net = require('net')
let rpio = require('rpio')
let Oled = require('sh1106-js')
```
Potrzebne będą również pewnie zmienne. Zmienna odpowiadająca za tryb robota, gdzie "0" odpowiada trybowi “drive” a “1” trybowi “freeDrive” w kodzie robota.
```
let moveMode = 0
```
Następnie zmienna, która odpowiada za aktualnie("true") i ostatnio(“false”) wciśnięty przycisk, celowo jest to maksymalnie jeden przycisk.
```
let pressed = { x: 0 , y: 0, state: false }
```
Oraz zmienna, która zawiera tablicę znaków do jazdy swobodnej ("freeDrive"). Przypisujemy przycisku do znaków,  jeżeli znak jest pusty, to nie zostanie wysłany do robota.
```
let freeDrive = [ 
  [ "", "", "", "" ],
  [ "", "", "", "" ],
  [ "", "z", "", "" ],
  [ "v", "x", "c", "" ]
]
```
Inicjalizujemy bibliotekę od Raspberry, ustawiamy opcję ekranu i je również inicjalizujemy.
```
rpio.init({

  gpiomem: false
})
var opts = {
  rpio,
  width: 128,
  height: 64,
  address: 0x3C,
  device: '/dev/i2c-1'
};
var oled = new Oled(opts)
oled.turnOnDisplay()
oled.fillRect(0, 0, 128, 64, 0)
```
Dodajemy zmienną, która odpowiada za piksele strzałek na wyświetlaczu.
```
[ // pusta
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  ],

  [ // góra
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0],
    [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
    [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
    [0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0],
    [0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0],
    [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0],
    [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0],
    [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0],
    [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0],
    [0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0],
    [0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0],
    [0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  ],
```
Pozwolę sobie nie wklejać tu jeszcze tablic dla strzałki "w dół", “w lewo” oraz “w prawo”. 

Następnie funkcje, dzięki którym odpowiednio narysujemy dany symbol na wyświetlaczu.
```
function drawSymbol(x, y, arr) {
  let tab = []
  for(let i in arr) {
    for(let j in arr[i]) {
      tab.push([(parseInt(x)+parseInt(j)), (parseInt(y)+parseInt(i)), arr[i][j]])
    }
  }
  oled.drawPixel(tab)
}
function drawButtonSymbol(i, j, id) {
  let x = j * 15 + 1
  let y = i * 15 + 1
  drawSymbol(x, y, symbols[id])
}
var font = require('oled-font-5x7');
```
Teraz odpowiednio przypisujemy piny malinki. Dla rzędów i kolumn,
```
let ROWS = [11, 10, 8, 7]
let COLS = [12, 13, 16, 15]
```
oraz dla dodatkowych przycisków (Start, Zmień tryb).
```
let EROWS = [21, 23]
let ECOL = 19
```
Potrzebna będzie jeszcze tablica znaków odpowiadających za ruchy,
```
let states = ['', 'u', 'd', 'l', 'r']
```
oraz tablica reprezentująca wartości maty z tablicy wyżej (states).
```
let values = [
  ['', '', '', ''],
  ['', '', '', ''],
  ['', '', '', ''],
  ['', '', '', '']
]
```
Istotnym jest również sprawdzenie, czy znaleziono robota, dlatego tworzymy zmienną "strażnik", która to sprawdza.
```
let connected = false
```
Następnie tworzymy klienta do wysyłania i odbierania socketów.
```
client = new net.Socket();
client.connect(12345, '192.168.1.200', function() {
    console.log('Connected')
  connected = true
})
```
Tworzymy tablicę, która będzie nas informować o tym czy przycisk jest wciśnięty. ("0" - nie, “1”- tak)
```
let buttons = [
  [0, 0, 0, 0],
  [0, 0, 0, 0],
  [0, 0, 0, 0],
  [0, 0, 0, 0]
]
```
Oraz identyczna tablica dla dwóch dodatkowych przycisków.
```
let buttons2 = [0, 0]
```
Następnie inicjalizujemy piny odpowiedzialne za klawiaturę 4x4,
```
for(let i in ROWS) {
  console.log("row: " + ROWS[i])
  rpio.open(ROWS[i], rpio.INPUT, rpio.PULL_DOWN)
}
for(let i in COLS) {
  rpio.open(COLS[i], rpio.OUTPUT, rpio.LOW)
}
```
oraz klawiaturę 2x1.
```
for(let i in EROWS) {
  console.log("erow: " + ROWS[i])
  rpio.open(EROWS[i], rpio.INPUT, rpio.PULL_DOWN)
}
rpio.open(ECOL, rpio.OUTPUT, rpio.LOW)
console.log("Initialised")
```
Uruchamiamy główną pętle programu.
```
checkPins()
```
Przechodzimy do głównej funkcji programu.
```
function checkPins() {
```
Najpierw dodajemy obsługę klawiatury 4x4
```
for(let i in COLS) {
    rpio.write(COLS[i], rpio.HIGH)
    for(let j in ROWS) {
      if(rpio.read(ROWS[j]) == 1) {
        if(buttons[j][i] == 0) {
          buttons[j][i] = 1
          pushButton(j, i)
        }
        else {
          pressedButton(j, i)
        }
      }
      else if(buttons[j][i] == 1) {
        buttons[j][i] = 0
        releaseButton(j, i)
      }
    }
    rpio.write(COLS[i], rpio.LOW)
  }
```
oraz klawiatury 2x1.
```
rpio.write(ECOL, rpio.HIGH)
  for(let i in EROWS) {
    if(rpio.read(EROWS[i]) == 1) {
      if(buttons2[i] == 0) {
        buttons2[i] = 1
        pushExtraButton(i)
      }
    }
    else if(buttons2[i] == 1) {
      buttons2[i] = 0
      releaseExtraButton(i)
    }
  }
  rpio.write(ECOL, rpio.LOW)
  //cycle++
  setTimeout(function(){ checkPins() }, 1)
}
```
Potrzebna jest również funkcja, która wykonuje się po wciśnięciu przycisku przez użytkownika. Funkcja ta dostaje odpowiedni znak, w zależności który przycisk został wciśnięty i następnie rysuje odpowiedni symbol na ekranie.
```
function pushButton(i, j) {
  console.log("Button (" + i + ", " + j + ") pushed")
  if (moveMode == 0) {
    let id = states.indexOf(values[i][j])
    id++
    if(id == states.length) {
      id = 0
    }
    values[i][j] = states[id]
    drawButtonSymbol(i, j, id)
    console.log("Values after (" + i + "," + j +") press: \n" + values)
  }
  else if(moveMode == 1) {
    if(pressed.state == false) {
      pressed.x = i
      pressed.y = j
      pressed.state = true
      if(freeDrive[i][j] != "") {
        client.write(freeDrive[i][j])
      }
    }
  }
}
```
Następnie potrzebujemy funkcji, która będzie się wykonywać kiedy przycisk z klawiatury 4x4 zostanie wciśnięty i przytrzymany w tym stanie. Funkcja ta służy do trybu jazdy swobodnej.
```
function pressedButton(i, j) {
  if(moveMode == 1 && false) {
    if(pressed.x == i && pressed.y == j) {
      if(freeDrive[i][j] != "") {
        client.write(freeDrive[i][j])
      }
    }
    else if(pressed.state == false) {
      pressed.x = i
      pressed.y = j
      pressed.state = true
    }
  }
}
```
Kolejna z funkcji, wykona się po puszczeniu trzymanego przycisku z klawiatury 4x4.
```
function releaseButton(i, j) {
  if(pressed.x == i && pressed.y == j && pressed.state) {
    pressed.state = false
    if(freeDrive[i][j] != "") {
      client.write("s")
    }
  }
  console.log("Button (" + i + ", " + j + ") released")
}
```
Dodatkowo funkcja, która przywraca narysowane strzałki. TU BĘDZIE ZMIANA
```
function drawActualArrows() {
  for(let i in values) {
    for(let j in values[i]) {
      let id = states.indexOf(values[i][j])
      if(id != -1) {
        drawButtonSymbol(i, j, id)
      }
    }
  }
}
```
Przedostatnia z funkcji, która wykonuje się po wciśnięciu przycisku z klawiatury 2x1. Odpowiedzialna za zmianę trybu oraz przycisku start.
```
function pushExtraButton(i) {
  console.log("Extra button(" + i + ") pushed")
  if(i == 1) {
    if(moveMode == 0) {
      moveMode = 1
      oled.fillRect(0, 0, 128, 64, 0)
    }
    else {
      moveMode = 0
      oled.fillRect(0, 0, 128, 64, 0)
      values = [
        ['', '', '', ''],
        ['', '', '', ''],
        ['', '', '', ''],
        ['', '', '', '']
      ]
    }
  }
  else if(i == 0) { //start button
    let s = ''
    for(let i in values) {
      for(let j in values[i]) {
        s += values[i][j]
      }
    }
    client.write(s)
    console.log("TCP packet sent: " + s)
  }
}
```
Na koniec funkcja, wykonująca się po puszczeniu przycisku z klawiatury 2x1.
```
function releaseExtraButton(i) {
  console.log("Extra button (" + i + ") released")
}
```
